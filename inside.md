<!--
 * @Author: ByronVon
 * @Date: 2023-08-10 12:32:06
 * @FilePath: /leetcode/inside.md
 * @Description: 
-->

# 刷题心得

下面是关于链表、二叉树和图的相关知识的总结，以及一些经典的练习题目：

## 数据结构

### 1. 链表

**要点**:

- 定义：每个元素（节点）包含两部分：值和指向下一个元素的指针。
- 可以是单向的或双向的。
- 常用于实现其他数据结构如堆栈和队列。

链表的遍历很简单，链表返回的时候要返回头部，因此node用于遍历，修改链接关系，返回head

```python
curr = head
while curr:
    curr = curr.next
```

**常见操作**:

- 插入元素
- 删除元素
- 反转链表
- 快慢指针

**经典题目**:

- 反转链表

```python
def reverseList(node):
    prev = None
    while node:
        next_node = node.next # 暂存结果
        node.next = prev # 修改当前节点的引用
        prev = node # prev->
        node = node.next # node->
    return prev
```

- 检测链表中的环
- 链表的中间节点（快慢指针）
- 合并两个有序链表
- 两个链表的交点

```python
def middleNode(head):
    slow, fast = head, head

    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    return slow
```

### 2. 二叉树

**要点**:

- 节点的度不能超过2。
- 分为多种类型，如：二叉搜索树、平衡二叉树、完全二叉树、堆等。

**遍历方法**:

- 前序遍历（DLR）

```python
def preorder(root):
    result = []
    def helper(node):
        if not node:
            return
        result.append(node.val)
        helper(node.left)
        helper(node.right)
    
    helper(root)
    return result
```

- 中序遍历（LDR）
- 后序遍历（LRD）
- 层次遍历（使用队列）

**经典题目**:

- 判断一个树是否为二叉搜索树
- 二叉树的最大深度
- 从前序和中序遍历构建二叉树
- 二叉树的镜像
- 路径总和

### 3. 图

**要点**:

- 由顶点和边组成。
- 可以是有向的或无向的。
- 可以有权或无权。
- 图的表示：邻接矩阵、邻接表。

**常见算法**:

- 深度优先搜索(DFS)
- 广度优先搜索(BFS)
- 最短路径：Dijkstra's、Bellman-Ford、Floyd-Warshall
- 拓扑排序
- 强连通分量：Tarjan、Kosaraju

**经典题目**:

- 图是否有环
- 无权图的最短路径
- 有权图的最短路径
- 图的拓扑排序
- 桥和割点

这些总结只是数据结构的基础概念和常见的问题。对于每一个主题，建议你深入阅读和练习，以确保充分理解和熟练掌握。

## 经典算法

### 1.滑动窗口

滑动是顺序遍历，但窗口的计算可以优化

遇到双循环，可以考虑用双指针进行优化

### 2.单调栈

通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。时间复杂度为O(n)。

### 3.哈希

列表的比较很费时，考虑用hash(str([]))来优化

### 4.动态规划

不适合从头开始推，而适合先从N处开始推，先定义状态，状态一般是求解的目标，然后求转移方程，最后确定边界条件

### 5.二分

二分的精髓就在于能否排序，所以遇到问题先考虑能否排序
二分的目的时为了检索，快速检索出想要的数字（如果存在的话）

```python
def binary_search(lst, n):
    # 如果已经保证数组是有序的，这一行可以去掉。
    lst.sort()  
    l, r = 0, len(lst) - 1
    while l <= r:
        m = (l + r) // 2
        if lst[m] == n:
            return True
        elif lst[m] < n:
            l = m + 1 # 直接将l变为m+1
        else:
            r = m - 1 # 直接将r变为n-1
    return False

def binary_search_index(lst, n):
    lst.sort()
    l, r = 0, len(lst)-1
    while l <= r:
        m = (l + r) // 2
        if lst[m] < n:
            l = m + 1
        else:
            r = m - 1
    return l
```

### 6.递归

递归是一种解决问题的策略，其中函数调用自身以解决较小的实例。理解递归的关键在于找到一个问题与其子问题之间的关系。以下是解决递归问题的一般步骤和思路：

1. **基本情况**: 这是递归的终止条件。对于每个递归问题，都需要定义一个或多个基本情况。当问题可以直接解决（不需要进一步的递归）时，它就成为基本情况。

2. **问题分解**: 将问题分解成一个或多个较小的子问题。这些子问题应该是原问题的更小实例，并且可以用相同的方法递归地解决。

3. **递归调用**: 使用递归调用来处理子问题。这意味着函数将调用自身，但是参数是原问题的一个子集。

4. **合并解决方案**: 一旦子问题被解决，可能需要合并它们的解决方案以获得原问题的解决方案。

以下是递归解决问题时要记住的几个要点：

- **清晰定义函数的目的**: 确保你知道函数的输入、输出以及它应该执行的任务。

- **不要深入递归**: 当你调用函数自身时，不要试图跟踪每一个递归调用，这会让你更加困惑。相反，信任递归。

- **绘制小例子**: 对于复杂的递归问题，手工跟踪一个简单的例子可能会很有帮助。

- **考虑效率**: 递归不总是最有效的解决方法。有时候递归会导致大量的重复计算。在这种情况下，可以考虑使用技术如备忘录（memoization）来存储和重用以前的结果。

### 7.双指针

双指针的核心问题在于怎么定义指针，从指针移动的角度来归纳，可以将双指针策略分类如下：

#### 1. **同向双指针**（一般是从头开始）

两个指针都从数组头部或链表头部开始移动，并且总是保持一个在另一个前面。这种类型的双指针通常用于滑动窗口或链表问题。

**应用场景**：

- 移动零，保证原顺序的情况下将零移动到数组末尾。
- 子数组的问题，如最长无重复子数组。
- 滑动窗口问题，如找到和为特定值的连续子数组。
- 链表问题，如检测链表中的循环或找到链表的中点。

#### 2. **对撞双指针**（从两侧开始）

两个指针分别从数组的开始和结束出发，然后向中间移动。这种类型的双指针经常用于有序数组或字符串的问题。

**应用场景**：

- 在排序数组中找两数之和、三数之和等。
- 两个字符串中的字符匹配问题。
- 容纳最多水的容器问题。

#### 3. **中心扩散指针**（从中间开始）

该策略适用于需要围绕某个中心扩展的问题，常用于字符串中搜索子串或回文的问题。

**应用场景**：

- 寻找字符串中的最长回文子串。

除了上述三种基本的双指针策略，还有一些混合或变种的策略，但它们通常是基于上述三种策略的组合或变体。

这三种策略基本上覆盖了双指针的主要应用场景。当然，双指针的核心思想是利用两个指针在结构中的相对位置或移动速度来解决问题，因此在具体问题中，可能需要根据问题特点灵活地设计指针的移动策略。
